/***********************************************************************************************//**
 * \file config_example.c
 *
 * \brief
 * Example demonstrating sensor configuration using register arrays
 * on Linux platforms including Yocto Embedded Linux.
 *
 ***************************************************************************************************
 * \copyright
 * Copyright 2022 Infineon Technologies AG
 * SPDX-License-Identifier: Apache-2.0
 **************************************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <getopt.h>
#include <stdbool.h>
#include <stdint.h>
#include <signal.h>

// Include the main library headers
#include "../xensiv_bgt60trxx.h"
#include "../xensiv_bgt60trxx_linux.h"

/*******************************************************************************
* Macros
*******************************************************************************/
#define DEFAULT_SPI_DEVICE      "/dev/spidev0.0"
#define DEFAULT_GPIO_CHIP       "/dev/gpiochip0"
#define DEFAULT_RST_GPIO        18
#define DEFAULT_CS_GPIO         24

/*******************************************************************************
* Sample Configuration
*******************************************************************************/
// This is a sample configuration array
// In practice, this would be generated by the BGT60TRxx configurator tool
static const uint32_t sample_config[] = {
    // Register address and value pairs
    // Format: (address << 25) | (value & 0x00FFFFFF)
    0x00000000,  // Placeholder - replace with actual configuration
    0x01000000,  // Placeholder - replace with actual configuration
    // Add more configuration registers as needed
};

static const uint32_t sample_config_len = sizeof(sample_config) / sizeof(sample_config[0]);

/*******************************************************************************
* Global Variables
*******************************************************************************/
static volatile bool g_running = true;
static xensiv_bgt60trxx_linux_obj_t g_sensor_obj;

/*******************************************************************************
* Function Prototypes
*******************************************************************************/
static void signal_handler(int sig);
static void print_usage(const char* program_name);
static void print_register_info(const xensiv_bgt60trxx_t* dev);

/*******************************************************************************
* Function Implementations
*******************************************************************************/

static void signal_handler(int sig)
{
    (void)sig;
    g_running = false;
    printf("\nShutdown requested...\n");
}

static void print_usage(const char* program_name)
{
    printf("Usage: %s [options]\n", program_name);
    printf("Options:\n");
    printf("  -s <device>    SPI device path (default: %s)\n", DEFAULT_SPI_DEVICE);
    printf("  -g <chip>      GPIO chip path (default: %s)\n", DEFAULT_GPIO_CHIP);
    printf("  -r <offset>    Reset GPIO offset (default: %d)\n", DEFAULT_RST_GPIO);
    printf("  -c <offset>    CS GPIO offset (default: %d)\n", DEFAULT_CS_GPIO);
    printf("  -h             Show this help message\n");
}

static void print_register_info(const xensiv_bgt60trxx_t* dev)
{
    int32_t result;
    uint32_t reg_value;
    
    printf("Register Information:\n");
    
    // Read some key registers
    const struct {
        uint32_t addr;
        const char* name;
    } registers[] = {
        {XENSIV_BGT60TRXX_REG_CHIP_ID, "CHIP_ID"},
        {XENSIV_BGT60TRXX_REG_MAIN, "MAIN"},
        {XENSIV_BGT60TRXX_REG_STAT1, "STAT1"},
        {XENSIV_BGT60TRXX_REG_ADC0, "ADC0"},
    };
    
    for (size_t i = 0; i < sizeof(registers) / sizeof(registers[0]); i++) {
        result = xensiv_bgt60trxx_get_reg(dev, registers[i].addr, &reg_value);
        if (result == XENSIV_BGT60TRXX_STATUS_OK) {
            printf("  %s (0x%02X): 0x%08X\n", 
                   registers[i].name, registers[i].addr, reg_value);
        } else {
            printf("  %s (0x%02X): Read failed (%d)\n", 
                   registers[i].name, registers[i].addr, result);
        }
    }
}

int main(int argc, char* argv[])
{
    const char* spi_device = DEFAULT_SPI_DEVICE;
    const char* gpio_chip = DEFAULT_GPIO_CHIP;
    unsigned int rst_gpio = DEFAULT_RST_GPIO;
    unsigned int cs_gpio = DEFAULT_CS_GPIO;
    int opt;
    int32_t result;

    // Parse command line arguments
    while ((opt = getopt(argc, argv, "s:g:r:c:h")) != -1) {
        switch (opt) {
            case 's':
                spi_device = optarg;
                break;
            case 'g':
                gpio_chip = optarg;
                break;
            case 'r':
                rst_gpio = (unsigned int)atoi(optarg);
                break;
            case 'c':
                cs_gpio = (unsigned int)atoi(optarg);
                break;
            case 'h':
                print_usage(argv[0]);
                return 0;
            default:
                print_usage(argv[0]);
                return 1;
        }
    }

    // Set up signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);

    printf("XENSIV BGT60TRxx Configuration Example\n");
    printf("======================================\n");

    // Initialize the sensor
    printf("Initializing sensor...\n");
    result = xensiv_bgt60trxx_linux_init_sensor(&g_sensor_obj,
                                               spi_device,
                                               gpio_chip,
                                               rst_gpio,
                                               cs_gpio,
                                               false);

    if (result != XENSIV_BGT60TRXX_STATUS_OK) {
        fprintf(stderr, "Failed to initialize sensor: %d\n", result);
        return 1;
    }

    printf("Sensor initialized successfully!\n\n");

    // Print initial register state
    printf("Initial register state:\n");
    print_register_info(&g_sensor_obj.dev);
    printf("\n");

    // Apply configuration
    printf("Applying configuration (%u registers)...\n", sample_config_len);
    
    if (sample_config_len > 0) {
        result = xensiv_bgt60trxx_config(&g_sensor_obj.dev, sample_config, sample_config_len);
        if (result == XENSIV_BGT60TRXX_STATUS_OK) {
            printf("Configuration applied successfully!\n");
        } else {
            fprintf(stderr, "Failed to apply configuration: %d\n", result);
        }
    } else {
        printf("No configuration to apply (using sample placeholder)\n");
        printf("In practice, replace sample_config[] with actual configuration\n");
        printf("generated by the BGT60TRxx configurator tool.\n");
    }

    printf("\n");

    // Print register state after configuration
    printf("Register state after configuration:\n");
    print_register_info(&g_sensor_obj.dev);
    printf("\n");

    // Test individual register access
    printf("Testing individual register access...\n");
    
    // Read current MAIN register value
    uint32_t main_reg;
    result = xensiv_bgt60trxx_get_reg(&g_sensor_obj.dev, XENSIV_BGT60TRXX_REG_MAIN, &main_reg);
    if (result == XENSIV_BGT60TRXX_STATUS_OK) {
        printf("Current MAIN register: 0x%08X\n", main_reg);
        
        // Modify a bit (example: toggle a non-critical bit)
        uint32_t modified_main = main_reg ^ 0x00000001; // Toggle LSB
        
        printf("Writing modified MAIN register: 0x%08X\n", modified_main);
        result = xensiv_bgt60trxx_set_reg(&g_sensor_obj.dev, XENSIV_BGT60TRXX_REG_MAIN, modified_main);
        if (result == XENSIV_BGT60TRXX_STATUS_OK) {
            printf("Register write successful\n");
            
            // Read back to verify
            uint32_t readback_main;
            result = xensiv_bgt60trxx_get_reg(&g_sensor_obj.dev, XENSIV_BGT60TRXX_REG_MAIN, &readback_main);
            if (result == XENSIV_BGT60TRXX_STATUS_OK) {
                printf("Readback MAIN register: 0x%08X\n", readback_main);
                if (readback_main == modified_main) {
                    printf("Register read/write test PASSED\n");
                } else {
                    printf("Register read/write test FAILED (expected 0x%08X, got 0x%08X)\n",
                           modified_main, readback_main);
                }
            }
        } else {
            fprintf(stderr, "Failed to write register: %d\n", result);
        }
    } else {
        fprintf(stderr, "Failed to read MAIN register: %d\n", result);
    }

    printf("\nConfiguration example completed.\n");
    printf("Press Ctrl+C to exit...\n");

    // Keep program running
    while (g_running) {
        sleep(1);
    }

    // Cleanup
    printf("Cleaning up...\n");
    xensiv_bgt60trxx_linux_deinit_sensor(&g_sensor_obj);
    
    printf("Configuration example completed successfully.\n");
    return 0;
}